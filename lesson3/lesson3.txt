1. 抽象類
	1.1 抽象方法 ---> 有些行為確實存在，但是必須到子類中才會有具體實現
									那麼這個時候，父類中只需要有聲明即可，不需要有實現
			如何聲明呢 ---> abstract 關鍵字
	1.2 如果一個類中含有抽象方法，該類就是抽象類
			必須用 abstract 關鍵字聲明
	1.3 抽象類就是用來繼承的
			當一個類繼承抽象類的時候，必須重寫抽象類的抽象方法
			，如果不重寫，則該類自己就會變成抽象類，必須用 abstract 聲明
	1.4 抽象類不能實例化，只能實例化其子類的對象
			只要看到抽象類的引用，引用的一定是其子類的實例
			如果看到函數的參數是抽象類，那麼調用函數時傳遞的是該抽象類
			子類的對象；如果看到函數的返回值類型是抽象，那麼返回的
			一定是該抽象類子類的實例對象
			
2. final 關鍵字，用來修飾
	變量：該變量只能賦值一次
				如果作為成員變量必須有初始值 (定義初始化or構造函數初始化)
	對象：final修飾對象，該對象只能引用一次(只有一個地址)，不能重新引用(不能更改地址)
	函數：final 修飾函數，該函數不能被重寫
	類：final 修飾類，該類不能被繼承，就斷子絕孫了
	
	final 和 abstract 不能一起使用
	private 和 abstract 也不能一起使用
	
3. 接口
	接口是一個標準，更多體現能干什麼，can-do
	抽象類體現的是繼承  is-a 關係
	3.1 接口用 interface 關鍵字聲明 ---> 地位等價於類，同樣會產生 .class 文件
	3.2 接口中所有的方法都是 public abstract 修飾的，即使沒有這樣聲明
			所以，所有方法都不能有實現
	3.3 定義了一個 CanFly 接口，我們就認為在編程中，實現了這個接口的
			類的對象，就具備飛的功能
			實現的時候用 implements 關鍵字
			實現接口，必須重寫接口中的抽象方法，否則自己變成了抽象類
			需要用abstract聲明
	3.4 接口是不能實例化的。
			接口中不能有構造函數，全部都是抽象的方法
			看到接口的引用，引用的一定是實現該接口的類的對象
	3.5 如何理解接口
			主機板製造商 ---> 主機板需要插入內存、顯卡......
			本來的順序是：主機板製造商需要等待內存製造商把內存做出來
									、顯卡製造商把顯卡做出來，才知道如何製造主機板
			但是現實生活中不是這樣，內存、顯卡都有標準，
			主機板就不用等了，直接根據標準預留接口即可
			這個標準就是接口
			案例：MainBoard/Memory/DisplayCard/Computer
	3.6 一個類可以實現多個接口：具備多個標準，具備多個功能
															(既是U盤又是mp3)
			就要實現各接口的所有方法
			
			一個類可以繼承一個類同時實現多個接口
			class A extends B implements C, D, E, ......
			class A is-a B, can-do C, D, E, .....
	3.7 java中是單一繼承，但是接口與接口之間可以進行多繼承，
			一個接口可以由多個接口繼承而來
	3.8 接口中甚至可以沒有任何方法，就是一套標準
			例如 Serializable, Cloneable
	3.9 接口中可以聲明變量，接口中聲明的變量都是
			public static final 的，即使沒有這樣聲明
	3.10 接口中有非常多的方法，而我們在用的時候，
			每次只用個別的方法，非常麻煩，可以寫一個適配器類 (見Demo10)
			這種缺省適配器類一般都是抽象的，明確指定不需要對象
			
			什麼是抽象類：只要是abstract聲明的類，就是抽象類 (不管有沒有抽象方法)
			
	4. 內部類 (只要是類就會產生class文件)
		4.1 成員內部類
				4.1.1 直接在外部類的其他成員中訪問，創建內部類的對象 (最簡單最常用的)
				4.1.2 如果成員內部類訪問權限為非private，直接訪問就可以
						Outer.Inner inner = outer.new Inner(參數); (用得較少)
				4.1.3 「類名.this」成員內部類中訪問外部類的當前對象
		4.2 靜態內部類
				4.2.1 直接在外部類的其他成員中訪問 (簡單常用)
				4.2.2 如果訪問權限為非private，直接創建對象
						Outer.Inner inner = new Outer.Inner();
				4.2.3 靜態內部類中只能訪問靜態的外部成員
		4.3 局部內部類
				一般聲明在某個函數的內部，只在該函數內有效，
				一樣會產生class文件
		4.4 匿名內部類 ---> (局部內部類的特殊情況)
				4.4.1 什麼時候用？
						已經知道父類，要獲取其子類的實例對象
						已經知道接口，要獲取實現了該接口的類的對象
						匿名類在用的時候，必須是直接獲取該匿名類的對象
				4.4.2 怎麼用？怎麼樣獲取對象呢？
						公式：「new 父類 or 接口 ( ) {
											子類的實現 or (實現了該接口的類的實現)
										}」
						公式得到的是匿名類的對象，or 實現了該接口 (繼承了該抽象類) 的類的實例對象
				4.4.3 上面的公式看起來都一樣，但是要注意有區別
							「new 父類(可以給父類的構造函數傳遞參數){子類實現}」
							接口沒有構造函數，不存在這個問題
				
		注意：在內部類中訪問局部變量，該變量必須聲明為final
					(在 java8 中，已經取消此限制)
				
				
				
				
			